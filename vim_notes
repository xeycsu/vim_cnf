J  连接多行
U  行撤消
ctr-r 重做
3a!<ESC> 输入三个!

单词移动:
   This is a line with example text ~
          --->-->->----------------->
           w  w  w    3w
s is a line with example text 
        <----<--<-<---------<---
           b   b b    2b      b
  This is a line with example text 
           <-   <--- ----->   ---->
           ge    ge     e       e
一个词以非单词字符结尾，例如 "."，"-" 或者 ")"。要改变 Vim 认为是单词组成部分
的字符，请参见 'iskeyword' 选项。
还可以用空白字符分隔的 "字串" (大写的 WORD) 移动。这不是我们通常意义的 "单
词"。这就是为什么使用大写形式的 WORD 的原因。按字串移动的命令也全都是大写的，
如下图所示:

           ge      b          w                             e
               <-     <-         --->                          --->
        This is-a line, with special/separated/words (and some more). 
           <----- <-----         -------------------->         ----->
             gE      B                   W                       E
               ge      b          w                             e



移动到行首或行尾
                  ^
             <------------
        .....This is a line with example text 
        <-----------------   --------------->
                0                  $


移动到一个指定的字符
        To err is human.  To really foul up you need a computer. 
        ---------->--------------->
            fh           fy

        To err is human.  To really foul up you need a computer. 
                  --------------------->
                           3fl
        To err is human.  To really foul up you need a computer. 
                  <---------------------
                            Fh

"tx" 命令与 "fx" 相似，但它只把光标移动到目标字符的前一个字符上。提示: "t" 表
示 "To" (到达)。这个命令的反向版本是 "Tx"。

        To err is human.  To really foul up you need a computer. 
                   <------------  ------------->
                        Th              tn

括号匹配
                            %
                         <----->
                if (a == (b * c) / d) 
                   <---------------->
                            %

这个命令也可适用于 [] 和 {}。(可用 'matchpairs' 选项定义)

当光标不在一个有用的字符上，"%" 会先正向查找找到一个。比如当光标停留在上例中的
行首时，"%" 会正向查找到第一个 "("。再按一次会移动到它的匹配处。

                if (a == (b * c) / d) 
                ---+---------------->







另一个定位行的方法是使用带计数前缀的 "%" 命令。例如，"50％" 移动到文件的中间，
而 "90%" 移到差不多结尾的位置。



                        +---------------------------+
                H -->   | text sample text          |
                        | sample text               |
                        | text sample text          |
                        | sample text               |
                M -->   | text sample text          |
                        | sample text               |
                        | text sample text          |
                        | sample text               |
                L -->   | text sample text          |
                        +---------------------------+



滚屏
CTRL-U 命令向下滚动半屏。想象一下通过一个视窗看着你的文本，然后把这个视窗向上
移动该窗口的一半高度。这样，窗口移动到当前文字的上面，而文字则移到窗口的下面。
不用担心记不住那边是上。很多人都是这样。
    CTRL-D 命令把视窗向下移动半屏，所以把文字向上移动半屏。

                                       +----------------+
                                       | some text      |
                                       | some text      |
                                       | some text      |
        +---------------+              | some text      |
        | some text     |  CTRL-U  --> |                |
        |               |              | 123456         |
        | 123456        |              +----------------+
        | 7890          |
        |               |              +----------------+
        | example       |  CTRL-D -->  | 7890           |
        +---------------+              |                |
                                       | example        |
                                       | example        |
                                       | example        |
                                       | example        |
                                       +----------------+

每次滚一行的命令是 CTRL-E (上滚) 和 CTRL-Y (下滚)。可以把 CTRL-E 想象为是多给
你一行 (one line Extra)。

正向滚动一整屏的命令是 CTRL-F (减去两行)。反向的命令是 CTRL-B。幸运地，CTRL-F
是向前 (forward) 滚动，CTRL-B 是向后 (backward) 滚动，这比较好记。

移动中的一个常见问题是，当你用 "j" 向下移动的时候，你的光标会处于屏幕的底部，
你可能希望，光标所在行处于屏幕的中间。这可以通过 "zz" 命令实现。

        +------------------+             +------------------+
        | some text        |             | some text        |
        | some text        |             | some text        |
        | some text        |             | some text        |
        | some text        |   zz  -->   | line with cursor |
        | some text        |             | some text        |
        | some text        |             | some text        |
        | line with cursor |             | some text        |
        +------------------+             +------------------+

"zt" 把光标所在行移动到屏幕的顶部，而 "zb" 则移动到屏幕的底部。Vim 中还有另外
一些用于滚动的命令，可以参见 |Q_sc|。要使光标上下总保留有几行处于视窗中用作上
下文，可以使用 'scrolloff' 选项。




查 找 整 个 单 词

如果你输入 "/the"，你也可能找到 "there"。要找到以 "the" 结尾的单词，可以用:

        /the\>

"\>" 是一个特殊的记号，表示只匹配单词末尾。类似地，"\<" 只匹配单词的开头。
这样，要匹配一个完整的单词 "the"，只需:

        /\<the\>

这不会匹配 "there" 或者 "soothe"。注意 "*" 和 "#" 命令也使用了 "词首" 和
"词尾" 标记来匹配整个单词 (要部分匹配，使用 "g*" 和 "g#")


    有一个简单的方法: 把光标移到那个单词下面使用 "*" 命令。Vim 会取得光标上的
单词并把它作为被查找的字符串。
    "#" 命令在反向完成相同的功能。你可以在命令前加一个计数: "3*" 查找光标下单
词第三次出现的地方。




当你用 "G" 命令跳到另一个地方，Vim 会记住你从什么地方跳过去的。这个位置成为一
个标记，要回到原来的地方，使用如下命令:

        ``

` 用单引号 ' 也可以。
    如果再次执行这个命令你会跳回去原来的地方，这是因为 ` 记住了自己跳转前的位
置。


你可以用如下命令取得所有的标记的列表:

        :marks





d num {motion}   motion: w e $ 0 ^ 
c num {motion} 



        x  表示  dl  (删除当前光标下的字符)
        X  表示  dh  (删除光标左边的字符)
        D  表示  d$  (删除到行尾)
        C  表示  c$  (修改到行尾)
        s  表示  cl  (修改一个字符)
        S  表示  cc  (修改一整行)




通过计数前缀，"r" 命令可以使多个字符被同一个字符替换，例如:

        There is something wrong here 
                           5rx

        There is something xxxxx here 




如果你在可视模式下选中了一些文字，然后你又发现你需要改变被选择的文字的另一端，
用 "o" 命令即可 (提示: "o" 表示 other end)，光标会移动到被选中文字的另一端，现
在你可以移动光标去改变选中文字的开始点了。再按 "o" 光标还会回到另一端。

当使用列块可视模式的时候，你会有四个角，"o" 只是把你移到对角上。而用 "O" 则能
移到同一行的另一个角上。

备注: "o" 和 "O" 在可视模式下与在普通模式下的作用有很大的不同；在普通模式下，
它们的作用是在光标后或前加入新的一行。


如果你在一个单词的中间而又想删掉这个单词，在你用 "dw" 前，你必须先移到这个单词
的开始处。这里还有一个更简单的方法: "daw"。

        this is some example text. 
                       daw

        this is some text. 

"daw" 的 "d" 是删除操作符。"aw" 是一个文本对象。提示: "aw" 表示 "A Word" (一个
单词)，这样，"daw" 就是 "Delete A Word" (删除一个单词)。确切地说，该单词后的空
格字符也被删除掉了。



        ~       修改光标下字符的大小写，并移动到下一个字符。这不是一个操作符
                (除非设置了 'tildeop')，所以你不能连接一个动作命令。这个命令在
                可视模式下也有效，它会改变被选中的所有文本的大小写。



如果要找一个选项，你可以在这里寻找帮助: |options|。另一个方法是用如下命令:

        :options




预 定 义 标 记

当你跳转到另一个文件后，有两个预定义的标记非常有用:

        `"

这个标记使你跳转到你上次离开这个文件时的位置。
另一个标记记住你最后一次修改文件的位置:

        `.



实际上还可以使用大写字母标记，这种标记是
全局的，它们可以在任何文件中使用




使 用 寄 存 器

当你需要拷贝一个文件的几个地方到另一个文件，用上面的方法，你就得反复在两个文件
间跳来跳去。要避免这种情况，你可以把不同的文本拷贝到不同的寄存器中。
    寄存器是 Vim 用来保存文本的地方。这里我们使用名称为 a 到 z 的寄存器 (后面
我们会发现还有其它寄存器)。让我们拷贝一个句子到 f 寄存器 (f 表示 First):

        "fyas

"yas" 命令象以前说过的那样拷贝一个句子，而 "f 告诉 Vim 把文本拷贝到寄存器 f 。
这必须放在拷贝命令的前面。
    现在，拷贝三个整行到寄存器 l (l 表示 line):

        "l3Y

计数前缀也可以用在 "l 的前面。要拷贝一个文本列块到寄存器 b (代表 block) 中:

        CTRL-Vjjww"by

注意 "b 正好在 "y" 命令的前面，这是必须的。把它放在 "w" 命令的前面就不行。
    现在你有了在寄存器 f，l 和 b 有三段文本。编辑另一个文件，并移到要插入文本
的地方:

        "fp

同样地，寄存器标识符 "f 必须在 "p" 命令的前面。
    你可以用任何顺序粘贴寄存器的内容。并且，这些内容一直存在于寄存器中，直到你
拷贝其它文件到这个寄存器中。这样，你可以粘贴任意多次。

    删除文本的时候，你也可以指定寄存器。使用这个方法可以移动几处文本。例如，要
删除一个单词并写到 w 寄存器中:

        "wdaw

同样地，寄存器标识符必须在删除命令 "d" 的前面。


关 闭 所 有 其 它 窗 口

如果你已经打开了一整套窗口，但现在只想编辑其中一个，如下命令可以完成这个功能:

        :only


下面命令打开另一个窗口并用该窗口编辑另一个指定的文件:

        :split two.c

如果你在编辑 one.c，则命令执行的结果是:

        +----------------------------------+
        |/* file two.c */                  |
        |~                                 |
        |~                                 |
        |two.c=============================|
        |/* file one.c */                  |
        |~                                 |
        |one.c=============================|
        |                                  |
        +----------------------------------+

要打开窗口编辑一个新文件，可以使用如下命令:

        :new



        CTRL-W h        跳转到左边的窗口
        CTRL-W j        跳转到下面的窗口
        CTRL-W k        跳转到上面的窗口
        CTRL-W l        跳转到右边的窗口

        CTRL-W t        跳转到最顶上的窗口
        CTRL-W b        跳转到最底下的窗口




"." 命令重复前一个修改操作。但如果你需要作一些更复杂的操作它就不行了。这时，记
录命令就变得很有效。这需要三个步骤:

1. "q{register}" 命令启动一次击键记录，结果保存到 {register} 指定的寄存器中。
   寄存器名可以用 a 到 z 中任一个字母表示。
2. 输入你的命令。
3. 键入 q (后面不用跟任何字符) 命令结束记录。

现在，你可以用 "@{register}" 命令执行这个宏。

现在看看你可以怎么用这些命令。假设你有如下文件名列表:

        stdio.h 
        fcntl.h 
        unistd.h 
        stdlib.h 

    而你想把它变成这样:

        #include "stdio.h" 
        #include "fcntl.h" 
        #include "unistd.h" 
        #include "stdlib.h" 

先移动到第一行，接着执行如下命令:

        qa                      启动记录，并使用寄存器 a
        ^                       移到行首
        i#include "<Esc>        在行首输入 #include "
        $                       移到行末
        a"<Esc>                 在行末加上双引号 (")
        j                       移到下一行
        q                       结束记录

现在，你已经完成一次复杂的修改了。你可以通过重复三次 "@a" 完成余下的修改。

"@a" 命令可以通过计数前缀修饰，使操作重复指定的次数。在本例中，你可以输入:

        3@a


你可能有多个地方需要修改。只要把光标移动到相应的位置并输入 "@a" 命令即可。如果
你已经执行过一次，你可以用 "@@" 完成这个操作，这更容易输入一些。例如，你上次使
用 "@b" 命令引用了寄存器 b，下一个 "@@" 命令将使用寄存器 b。
    如果你对回放命令和 "." 命令作一个比较，你会发现几个区别。首先，"." 只能重
复一次改动。而在上例中，"@a" 可以重复多次改动，还能够执行移动操作。第二， "."
只能记住最后一次变更操作。而寄存器执行命令允许你记录任何操作并使用象 "@a" 这样
的命令回放这些被记录的操作。最后，你可以使用 26 个寄存器，因此，你可以记录多达
26 个命令序列。



保 存 部 分 行

要把一部分行写入到文件，可以使用 ":write" 命令。在没有指定范围的时候它写入全
文，而指定范围的时候它只写入范围指定的行:

        :.,$write tempo

这个命令写入当前位置到文件末的全部行到文件 "tempo" 中。如果这个文件已经存在，
你会被提示错误。Vim 不会让你直接写入到一个已存在的文件。如果你知道你在干什么而
且确实想这样做，就加一个叹号:

        :.,$write! tempo


 单词替换

替换命令可以在全文中用一个单词替换另一个单词:

        :%s/four/4/g

"%" 范围前缀表示在所有行中执行替换。最后的 "g" 标记表示替换行中的所有匹配点。
    如果你有一个象 "thirtyfour" 这样的单词，上面的命令会出错。这种情况下，这
个单词会被替换成 "thirty4"。要解决这个问题，用 "\<" 来指定匹配单词开头:

        :%s/\<four/4/g

显然，这样在处理 "fourteen" 的时候还是会出错。用 "\>" 来解决这个问题:

        :%s/\<four\>/4/g

如果你在编码，你可能只想替换注释中的 "four"，而保留代码中的。由于这很难指定，
可以在替换命令中加一个 "c" 标记，这样，Vim 会在每次替换前提示你:

        :%s/\<four\>/4/gc




映 射 与 运 行 模 式

":map" 命令定义普通模式的键映射。你也可以为其它运行模式定义映射。例如，":imap"
用来定义插入模式的映射。你可以用它来定义一个插入日期的映射:

        :imap <F2> <CR>Date: <Esc>:read !date<CR>kJ

看起来很象前面为普通模式定义的 <F2> 映射。只是开始的地方有所不同。普通模式下的
<F2> 映射依然有效。这样你就可以在各种模式下为同一映射键定义不同的映射。
   应该注意的是，虽然这个映射以插入模式开始，但它却以普通模式结束。如果你希望
继续插入模式，可以在最后加上 "a"。

下面是一个映射命令及其生效模式的总览:

        :map            普通，可视模式及操作符等待模式
        :vmap           可视模式
        :nmap           普通模式
        :omap           操作符等待模式
        :map!           插入和命令行模式
        :imap           插入模式
        :cmap           命令行模式

操作符等待模式是当你键入一个操作符 (比如 "d" 或 "y") 之后，Vim 期待你键入一个
动作命令或者文本对象时的状态。比如，当你键入命令 "dw"， 那个 "w" 就是在操作符
等待模式下键入的。

假定你想定义映射 <F7> 使得命令 d<F7> 删除一个 C 程序块 ({} 包括的文本)。类似的
y<F7> 会将程序块拷贝到匿名的寄存器。因此，你所要做的就是定义 <F7> 来选择当前的
语法块。你可以用下面的命令做到:

        :omap <F7> a{

这使得 <F7> 在操作符等待模式下选择一个块，就像是你键入了 "a{" 一样。这个映射在
你不容易键入 { 时比较有用。




 要避免键被再次映射，使用 ":noremap" 命令:

        :noremap        普通，可视和操作符等待模式
        :vnoremap       可视模式
        :nnoremap       普通模式
        :onoremap       操作符等待模式
        :noremap!       插入和命令行模式
        :inoremap       插入模式
        :cnoremap       命令行模式



